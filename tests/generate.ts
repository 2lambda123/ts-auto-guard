import test from 'tape'
import { Project } from 'ts-morph'
import { minify, MinifyOptions } from 'uglify-js'
import { IProcessOptions, processProject } from '../src'

function createProject(): Project {
  return new Project({
    skipAddingFilesFromTsConfig: true,
    compilerOptions: { strict: true },
    useInMemoryFileSystem: true,
  })
}

interface ITestOptions {
  skip?: boolean
  only?: boolean
  minifyOptions?: MinifyOptions
  options?: IProcessOptions
  throws?: RegExp | typeof Error
}

function testProcessProject(
  typeDescription: string,
  input: { readonly [filename: string]: string },
  output: { readonly [filename: string]: string | null },
  { skip, only, options, minifyOptions, throws }: ITestOptions = {}
) {
  const fn = skip ? test.skip : only ? test.only : test
  fn(typeDescription, t => {
    const project = createProject()
    Object.entries(input).forEach(([filePath, content]) => {
      project.createSourceFile(filePath, content)
    })
    project.saveSync()

    const expectedFilenames = new Set(Object.keys(output))

    if (throws) {
      t.throws(() => {
        processProject(project, options)
      }, throws)
      t.end()
      return
    }

    t.doesNotThrow(() => {
      processProject(project, options)
    })

    for (const sourceFile of project.getSourceFiles()) {
      const filePath = sourceFile.getFilePath().slice(1)
      const expectedRaw = output[filePath]
      if (expectedRaw === undefined) {
        t.fail(`unexpected file ${filePath}`)
      } else if (expectedRaw === null) {
        // This file is expected, but must not have been changed
        expectedFilenames.delete(filePath)
        const sourceText = sourceFile.getFullText()
        t.equal(sourceText, input[filePath], `${filePath} should not change`)
      } else {
        // This is a new file
        expectedFilenames.delete(filePath)
        const expectedFile = project.createSourceFile(
          `${filePath}.expected`,
          expectedRaw
        )
        let sourceText: string
        if (minifyOptions !== undefined) {
          const emitOutput = sourceFile.getEmitOutput()
          const result = minify(
            emitOutput.getOutputFiles()[0].getText(),
            minifyOptions
          )
          t.error(result.error, 'UglifyJS should succeed')
          sourceText = result.code
        } else {
          expectedFile.formatText()
          sourceText = sourceFile.getText()
        }

        const expectedText = expectedFile.getText()
        t.equal(sourceText, expectedText, `${filePath} should match`)
      }
    }
    for (const filePath of expectedFilenames) {
      t.fail(`${filePath} not found`)
    }
    t.end()
  })
}

testProcessProject(
  'removes existing .guard.ts files',
  {
    'test.guard.ts': `/* WARNING: Do not manually change this file. */ alert("hello")`,
  },
  {}
)

testProcessProject(
  'does not touch .guard.ts files that are not autogenerated',
  { 'test.guard.ts': `alert("hello")` },
  { 'test.guard.ts': null }
)

testProcessProject(
  'removes correct .guard.ts files when guardFileName is set',
  {
    'test.foo.ts': `/* WARNING: Do not manually change this file. */alert("hello")`,
    'test.guard.ts': `/* WARNING: Do not manually change this file. */alert("hello")`,
  },
  { 'test.guard.ts': null },
  { options: { guardFileName: 'foo' } }
)

const invalidGuardFileNameCharacters = ['*', '/']
for (const invalidCharacter of invalidGuardFileNameCharacters) {
  testProcessProject(
    `rejects invalid guardFileNames: ${invalidCharacter}`,
    {},
    {},
    {
      options: { guardFileName: `f${invalidCharacter}o` },
      throws: /guardFileName/,
    }
  )
}

testProcessProject(
  'generates type guards for empty object if exportAll is true',
  {
    'test.ts': `
    export interface Empty {}`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Empty } from "./test";

    export function isEmpty(obj: unknown): obj is Empty {
        const typedObj = obj as Empty
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function")
        )
    }`,
  },
  { options: { exportAll: true, debug: false } }
)

testProcessProject(
  'generates type guards for JSDoc @see with @link tag',
  {
    'test.ts': `
    /** @see {@link isBool} ts-auto-guard:type-guard */
    export type Bool = boolean`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Bool } from "./test";

    export function isBool(obj: unknown): obj is Bool {
        const typedObj = obj as Bool
        return (
            typeof typedObj === "boolean"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for boolean',
  {
    'test.ts': `
    /** @see {isBool} ts-auto-guard:type-guard */
    export type Bool = boolean`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Bool } from "./test";

    export function isBool(obj: unknown): obj is Bool {
        const typedObj = obj as Bool
        return (
            typeof typedObj === "boolean"
        )
    }`,
  }
)

testProcessProject(
  'allows the name of the guard file file to be specified',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      foo: number,
      bar: string
    }`,
  },
  {
    'test.ts': null,
    'test.debug.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj.foo === "number" &&
            typeof typedObj.bar === "string"
        )
    }`,
  },
  {
    options: {
      guardFileName: 'debug',
    },
  }
)

testProcessProject(
  'show debug info',
  {
    [`foo/bar/test.ts`]: `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      foo: number,
      bar: Bar,
      bars: Array<Bar>
    }

    /** @see {isBar} ts-auto-guard:type-guard */
    export interface Bar {
      bar: number,
    }

    `,
  },
  {
    [`foo/bar/test.ts`]: null,
    [`foo/bar/test.guard.ts`]: `
    import { Foo, Bar } from "./test";

    function evaluate(
      isCorrect: boolean,
      varName: string,
      expected: string,
      actual: any
    ): boolean {
      if (!isCorrect) {
        console.error(
          \`\${varName} type mismatch, expected: \${expected}, found:\`,
                      actual
          )
      }
      return isCorrect
    }

    export function isFoo(obj: unknown, argumentName: string = "foo"): obj is Foo {
      const typedObj = obj as Foo
      return (
        (typedObj !== null &&
          typeof typedObj === "object" ||
          typeof typedObj === "function") &&
          evaluate(typeof typedObj.foo === "number", \`\${argumentName}.foo\`, "number", typedObj.foo) &&
          evaluate(isBar(typedObj.bar) as boolean, \`\${argumentName}.bar\`, "import(\\"/foo/bar/test\\").Bar", typedObj.bar) &&
          evaluate(Array.isArray(typedObj.bars) &&
            typedObj.bars.every((e: any) =>
              isBar(e) as boolean
            ), \`\${argumentName}.bars\`, "import(\\"/foo/bar/test\\").Bar[]", typedObj.bars)
        )
    }

    export function isBar(obj: unknown, argumentName: string = "bar"): obj is Bar {
      const typedObj = obj as Bar
      return (
        (typedObj !== null &&
          typeof typedObj === "object" ||
          typeof typedObj === "function") &&
          evaluate(typeof typedObj.bar === "number", \`\${argumentName}.bar\`, "number", typedObj.bar)
        )
    }
    `,
  },
  {
    options: {
      debug: true,
    },
  }
)

testProcessProject(
  'uses correct import file name if guard file is renamed',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      foo: number,
      bar: string
    }`,
  },
  {
    'test.ts': null,
    'test.debug.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj.foo === "number" &&
            typeof typedObj.bar === "string"
        )
    }`,
  },
  {
    options: {
      guardFileName: 'debug',
      importGuards: 'CustomGuardAlias',
    },
    skip: true,
  }
)

testProcessProject(
  'generates type guards for simple interface',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      foo: number,
      bar: string
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj.foo === "number" &&
            typeof typedObj.bar === "string"
        )
    }`,
  }
)

// characters that are currently not supported include double quotes, backslashes and newlines
const nonAlphanumericCharacterPropertyNames = [
  '\0',
  ' ',
  '-',
  '+',
  '*',
  '/',
  '.',
  'foo bar',
  'foo-bar',
  'foo+bar',
  'foo*bar',
  'foo/bar',
  'foo.bar',
  "'foobar'",
  '#hashtag',
  '1337_leadingNumbers',
]

for (const propertyName of nonAlphanumericCharacterPropertyNames) {
  testProcessProject(
    `generates type guards for interface property with non-alphanumeric name '${propertyName}'`,
    {
      'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      "${propertyName}": number
    }`,
    },
    {
      'test.ts': null,
      'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj["${propertyName}"] === "number"
        )
    }`,
    }
  )

  testProcessProject(
    `generates type guards for type property with non-alphanumeric name '${propertyName}'`,
    {
      'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export type Foo = {
      "${propertyName}": number
    }`,
    },
    {
      'test.ts': null,
      'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj["${propertyName}"] === "number"
        )
    }`,
    }
  )
}

testProcessProject(
  'generates type guards for interface properties with numerical names',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      "1": number,
      "2": string
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj["1"] === "number" &&
            typeof typedObj["2"] === "string"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for type properties with numerical names',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export type Foo = {
      "1": number,
      "2": string
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj["1"] === "number" &&
            typeof typedObj["2"] === "string"
        )
    }`,
  }
)
testProcessProject(
  'generates type guards for interface property with empty string as name',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      "": number
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj[""] === "number"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for type property with empty string as name',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export type Foo = {
      "": number
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
            typeof typedObj === "object" ||
            typeof typedObj === "function") &&
            typeof typedObj[""] === "number"
        )
    }`,
  }
)

testProcessProject(
  'correctly handles default export',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    interface Foo {
      foo: number,
      bar: string
    }

    export default Foo`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import Foo from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.foo === "number" &&
            typeof typedObj.bar === "string"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for interface with optional field',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      foo?: number,
      bar: number | undefined,
      baz?: number | undefined
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            ( typeof typedObj.foo === "undefined" ||
              typeof typedObj.foo === "number" ) &&
            ( typeof typedObj.bar === "undefined" ||
              typeof typedObj.bar === "number" ) &&
            ( typeof typedObj.baz === "undefined" ||
              typeof typedObj.baz === "number" )
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for nested interface',
  {
    'test.ts': `
    interface Bar {
      bar: number
    }

    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      foo: Bar,
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            (typedObj.foo !== null &&
              typeof typedObj.foo === "object" ||
              typeof typedObj.foo === "function") &&
            typeof typedObj.foo.bar === "number"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for nested interface with type guard',
  {
    'test.ts': `
    /** @see {isBar} ts-auto-guard:type-guard */
    export interface Bar {
      bar: number
    }

    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo {
      foo: Bar,
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Bar, Foo } from "./test";

    export function isBar(obj: unknown): obj is Bar {
        const typedObj = obj as Bar
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.bar === "number"
        )
    }

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            isBar(typedObj.foo) as boolean
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for interface extending other interface',
  {
    'test.ts': `
    interface Bar {
      bar: number
    }

    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo extends Bar {
      foo: number,
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.bar === "number" &&
            typeof typedObj.foo === "number"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for interface extending other interface with type guard',
  {
    'test.ts': `
    /** @see {isBar} ts-auto-guard:type-guard */
    export interface Bar {
      bar: number
    }

    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo extends Bar {
      foo: number
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Bar, Foo } from "./test";

    export function isBar(obj: unknown): obj is Bar {
        const typedObj = obj as Bar
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.bar === "number"
        )
    }

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            isBar(typedObj) as boolean &&
            typeof typedObj.foo === "number"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for interface extending object type',
  {
    'test.ts': `
    export type Bar = {
      bar: number
    }

    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo extends Bar {
      foo: number
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.bar === "number" &&
            typeof typedObj.foo === "number"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for interface extending object type with type guard',
  {
    'test.ts': `
    /** @see {isBar} ts-auto-guard:type-guard */
    export type Bar = {
      bar: number
    }

    /** @see {isFoo} ts-auto-guard:type-guard */
    export interface Foo extends Bar {
      foo: number
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Bar, Foo } from "./test";

    export function isBar(obj: unknown): obj is Bar {
        const typedObj = obj as Bar
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.bar === "number"
        )
    }

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            isBar(typedObj) as boolean &&
            typeof typedObj.foo === "number"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for an object literal type',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export type Foo = {
      foo: number
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.foo === "number"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards for a Pick<> type',
  {
    'test.ts': `
    interface Bar {
      foo: number,
      bar: number
    }

    /** @see {isFoo} ts-auto-guard:type-guard */
    export type Foo = Pick<Bar, "foo">`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.foo === "number"
        )
    }`,
  }
)

testProcessProject(
  'generates type guards with a short circuit',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export type Foo = {
      foo: number
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Foo } from "./test";

    export function isFoo(obj: unknown): obj is Foo {
        if (DEBUG) return true
        const typedObj = obj as Foo
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
            typeof typedObj.foo === "number"
        )
    }`,
  },
  {
    options: { shortCircuitCondition: 'DEBUG', debug: false },
  }
)

testProcessProject(
  'generated type guards with a short circuit are correctly stripped by UglifyJS',
  {
    'test.ts': `
    /** @see {isFoo} ts-auto-guard:type-guard */
    export type Foo = {
      foo: number,
      bar: Foo | string | () => void,
      baz: "foo" | "bar"
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `"use strict";function isFoo(o){return!0}exports.__esModule=!0,exports.isFoo=void 0,exports.isFoo=isFoo;`,
  },
  {
    minifyOptions: {
      compress: { global_defs: { DEBUG: true } },
    },
    options: { shortCircuitCondition: 'DEBUG', debug: false },
  }
)

testProcessProject(
  'generates type guards for mapped types',
  {
    'test.ts': `
    /** @see {isPropertyValueType} ts-auto-guard:type-guard */
    export type PropertyValueType = {value: string};

    /** @see {isPropertyName} ts-auto-guard:type-guard */
    export type PropertyName = 'name' | 'value';

    /** @see {isFoo} ts-auto-guard:type-guard */
    export type Foo = {
      [key in PropertyName]: PropertyValueType
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
     import { PropertyValueType, PropertyName, Foo } from "./test";

     export function isPropertyValueType(obj: unknown): obj is PropertyValueType {
        const typedObj = obj as PropertyValueType
        return (
            (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
          typeof typedObj.value === "string"
          )
      }

     export function isPropertyName(obj: unknown): obj is PropertyName {
       const typedObj = obj as PropertyName
       return (
         (typedObj === "name" ||
           typedObj === "value")
       )
     }

     export function isFoo(obj: unknown): obj is Foo {
       const typedObj = obj as Foo
       return (
         (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function") &&
         isPropertyValueType(typedObj.name) as boolean &&
         isPropertyValueType(typedObj.value) as boolean
       )
     }
    `,
  }
)

testProcessProject(
  'generates type guards for recursive types',
  {
    'test.ts': `
   /** @see {isBranch1} ts-auto-guard:type-guard */
   export type Branch1 = Branch1[] | string;

   /** @see {isBranch2} ts-auto-guard:type-guard */
   export type Branch2 = { branches: Branch2[] } | string;

   /** @see {isBranch3} ts-auto-guard:type-guard */
   export type Branch3 = { branches: Branch3[] } | {branches: Branch3 }[] | string;
    `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Branch1, Branch2, Branch3 } from "./test";

    export function isBranch1(obj: unknown): obj is Branch1 {
        const typedObj = obj as Branch1
        return (
            (typeof typedObj === "string" ||
                Array.isArray(typedObj) &&
                typedObj.every((e: any) =>
                    isBranch1(e) as boolean
                ))
        )
    }

    export function isBranch2(obj: unknown): obj is Branch2 {
        const typedObj = obj as Branch2
        return (
            (typeof typedObj === "string" ||
            (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
                Array.isArray(typedObj.branches) &&
                typedObj.branches.every((e: any) =>
                    isBranch2(e) as boolean
                ))
        )
    }

    export function isBranch3(obj: unknown): obj is Branch3 {
        const typedObj = obj as Branch3
        return (
            (typeof typedObj === "string" ||
                (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
                Array.isArray(typedObj.branches) &&
                typedObj.branches.every((e: any) =>
                    isBranch3(e) as boolean
                ) ||
                Array.isArray(typedObj) &&
                typedObj.every((e: any) =>
                    (e !== null &&
                      typeof e === "object" ||
                      typeof e === "function")  &&
                    isBranch3(e.branches) as boolean
                ))
        )
    }`,
  }
)

testProcessProject(
  'generated type guards for discriminated unions',
  {
    'test.ts': `
    export type X = { type: 'a', value: number } | { type: 'b', value: string }
    `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { X } from "./test";

    export function isX(obj: unknown): obj is X {
        const typedObj = obj as X
        return (
            ((typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
                typedObj.type === "a" &&
                typeof typedObj.value === "number" ||
                (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
                typedObj.type === "b" &&
                typeof typedObj.value === "string")
            )
    }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'generated type guards for enums',
  {
    'test.ts': `
    export enum Types{
        TheGood,
        TheBad,
        TheTypeSafe
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { Types } from "./test";

    export function isTypes(obj: unknown): obj is Types {
        const typedObj = obj as Types
        return (
            (typedObj === Types.TheGood ||
                typedObj === Types.TheBad ||
                typedObj === Types.TheTypeSafe)
        )
    }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'generated type guards for numeric enums in optional records',
  {
    'test.ts': `
    export enum Types{
        TheGood = 1,
        TheBad,
        TheTypeSafe
    }
    export interface TestItem  {
      room: Partial<Record<Types, string>>>;
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { Types, TestItem } from "./test";

      export function isTypes(obj: unknown): obj is Types {
          const typedObj = obj as Types
          return (
              (typedObj === Types.TheGood ||
                  typedObj === Types.TheBad ||
                  typedObj === Types.TheTypeSafe)
          )
      }

      export function isTestItem(obj: unknown): obj is TestItem {
          const typedObj = obj as TestItem
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              (typedObj.room !== null &&
                  typeof typedObj.room === "object" ||
                  typeof typedObj.room === "function") &&
              (typeof typedObj.room["1"] === "undefined" ||
                  typeof typedObj.room["1"] === "string") &&
              (typeof typedObj.room["2"] === "undefined" ||
                  typeof typedObj.room["2"] === "string") &&
              (typeof typedObj.room["3"] === "undefined" ||
                  typeof typedObj.room["3"] === "string")
          )
      }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'generated type guards for arrays of any',
  {
    'test.ts': `
      export interface Foo {
        value: any[]
      }
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { Foo } from "./test";

      export function isFoo(obj: unknown): obj is Foo {
          const typedObj = obj as Foo
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              Array.isArray(typedObj.value)
          )
      }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'generated type guards for nested arrays',
  {
    'test.ts': `
      export type Foo = {
        value: Array<{
          value: Array<number>
        }>
      }
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
        import { Foo } from "./test";

        export function isFoo(obj: unknown): obj is Foo {
            const typedObj = obj as Foo
            return (
                (typedObj !== null &&
                    typeof typedObj === "object" ||
                    typeof typedObj === "function") &&
                Array.isArray(typedObj.value) &&
                typedObj.value.every((e: any) =>
                    (e !== null &&
                        typeof e === "object" ||
                        typeof e === "function") &&
                    Array.isArray(e.value) &&
                    e.value.every((e: any) =>
                        typeof e === "number"
                    )
                )
            )
        }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'type that is an alias to an interface has a different typeguard name',
  {
    'test.ts': `
      export interface TestType {
          [index: any]: string
      }
      export type SecondaryTestType = TestType
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType, SecondaryTestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              Object.entries<any>(typedObj)
                  .every(([_key, value]) => (typeof value === "string"))
          )
      }

      export function isSecondaryTestType(obj: unknown): obj is SecondaryTestType {
        const typedObj = obj as SecondaryTestType
        return (
            (typedObj !== null &&
                typeof typedObj === "object" ||
                typeof typedObj === "function") &&
            Object.entries<any>(typedObj)
                .every(([_key, value]) => (typeof value === "string"))
        )
      }
      `,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'adds type guard import to source file and also exports',
  {
    // NOTE: This file is not automatically cleaned up with `formatText` after
    // being modified so it requires this funky indentation to ensure that it is
    // conforms to ts-morph's formatting.
    'test.ts': `
/** @see {isEmpty} ts-auto-guard:type-guard */
export interface Empty { }
`,
  },
  {
    'test.ts': `
    import * as CustomGuardAlias from "./test.guard";

    /** @see {isEmpty} ts-auto-guard:type-guard */
    export interface Empty {}
    export { CustomGuardAlias };`,
    'test.guard.ts': `
    import { Empty } from "./test";

    export function isEmpty(obj: unknown): obj is Empty {
        const typedObj = obj as Empty
        return (
              (typedObj !== null &&
              typeof typedObj === "object" ||
              typeof typedObj === "function")
           )
    }`,
  },
  { options: { importGuards: 'CustomGuardAlias' } }
)

testProcessProject(
  'imports and uses generated type guard if the type is used in another file',
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export interface TestType {
          someKey: string | number
      }
      `,
    'test-list.ts': `
      import { TestType } from './test'

      /** @see {isTestTypeList} ts-auto-guard:type-guard */
      export type TestTypeList = Array<TestType>
      `,
  },
  {
    'test.ts': null,
    'test-list.ts': null,
    'test-list.guard.ts': `
      import { isTestType } from "./test.guard";
      import { TestTypeList } from "./test-list";

      export function isTestTypeList(obj: unknown): obj is TestTypeList {
          const typedObj = obj as TestTypeList
          return (
              Array.isArray(typedObj) &&
              typedObj.every((e: any) =>
                  isTestType(e) as boolean
              )
          )
      }
      `,
    'test.guard.ts': `
        import { TestType } from "./test";

        export function isTestType(obj: unknown): obj is TestType {
            const typedObj = obj as TestType
            return (
                (typedObj !== null &&
                    typeof typedObj === "object" ||
                    typeof typedObj === "function") &&
                (typeof typedObj.someKey === "string" ||
                    typeof typedObj.someKey === "number")
            )
        }
        `,
  }
)

testProcessProject(
  'generates type guards for dynamic object keys, including when mixed with static keys',
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export interface TestType {
          someKey: "some" | "key"
          [index: string]: "dynamic" | "string"
          [index: number]: "also-dynamic" | "number"
      }
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              (typedObj.someKey === "some" ||
                  typedObj.someKey === "key") &&
              Object.entries<any>(typedObj)
                  .filter(([key]) => !["someKey"].includes(key))
                  .every(([key, value]) => ((value === "string" ||
                      value === "dynamic") &&
                      typeof key === "string" ||
                      (value === "number" ||
                          value === "also-dynamic") &&
                      typeof key === "number"))
          )
      }
      `,
  }
)

testProcessProject(
  'generates type guards for Record types',
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export type TestType = Record<string, "dynamic" | "string">
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              Object.entries<any>(typedObj)
                  .every(([key, value]) => ((value === "string" ||
                      value === "dynamic") &&
                      typeof key === "string"))
          )
      }
      `,
  }
)

testProcessProject(
  'prefixes value with underscore if it goes unused',
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export interface TestType {
          [index: string]: any
      }
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              Object.entries<any>(typedObj)
                  .every(([key, _value]) => (typeof key === "string"))
          )
      }
      `,
  }
)

testProcessProject(
  'prefixes key with underscore if it goes unused',
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export interface TestType {
          [index: any]: string
      }
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              Object.entries<any>(typedObj)
                  .every(([_key, value]) => (typeof value === "string"))
          )
      }
      `,
  }
)

testProcessProject(
  'Does not generate empty guard files',
  {
    'test.ts': '',
  },
  { 'test.ts': null }
)

testProcessProject(
  'Deals with unknown type as it would any',
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export interface TestType {
          [index: string]: unknown
      }
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              Object.entries<any>(typedObj)
                  .every(([key, _value]) => (typeof key === "string"))
          )
      }
      `,
  }
)

testProcessProject(
  'Deals with unknown type as it would any',
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export interface TestType {
          test: unknown
      }
      `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function")
          )
      }
      `,
  }
)

testProcessProject(
  'Check if any callable properties is a function',
  // should also emit a warning about how it is not possible to check function type at runtime.
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export interface TestType {
        test: (() => void)
        // ts-auto-guard-suppress function-type
        test2(someArg: number): boolean
        // some other comments
        test3: {
          (someArg: string): number
          test3Arg: number;
        }
      }
    `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
              typeof typedObj.test === "function" &&
              typeof typedObj.test3 === "function" &&
              typeof typedObj.test3.test3Arg === "number" &&
              typeof typedObj.test2 === "function"
          )
      }
    `,
  }
)

testProcessProject(
  'Check if callable interface is a function',
  // should also emit a warning about how it is not possible to check function type at runtime.
  {
    'test.ts': `
      /** @see {isTestType} ts-auto-guard:type-guard */
      export interface TestType {
        (someArg: string): number
        arg: number;
      }
    `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
      import { TestType } from "./test";

      export function isTestType(obj: unknown): obj is TestType {
          const typedObj = obj as TestType
          return (
              typeof typedObj === "function" &&
              typeof typedObj.arg === "number"
          )
      }
    `,
  }
)

testProcessProject(
  'generated type guards for intersection type',
  {
    'test.ts': `
    export type X = { foo: number } & { bar: string }
    `,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { X } from "./test";

    export function isX(obj: unknown): obj is X {
        const typedObj = obj as X
        return (
            (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
                typeof typedObj.foo === "number" &&
                (typedObj !== null &&
                  typeof typedObj === "object" ||
                  typeof typedObj === "function") &&
                typeof typedObj.bar === "string"
            )
    }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'generates tuples',
  {
    'test.ts': `
    export interface A {
      b: [number]
    }`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { A } from "./test";

    export function isA(obj: unknown): obj is A {
        const typedObj = obj as A
        return (
            (typedObj !== null &&
                typeof typedObj === "object" ||
                typeof typedObj === "function") &&
            Array.isArray(typedObj.b) &&
            typeof typedObj.b[0] === "number"
        )
    }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'skips checking any type in array',
  {
    'test.ts': `export type A = any[]`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { A } from "./test";

    export function isA(obj: unknown): obj is A {
        const typedObj = obj as A
        return (
          Array.isArray(typedObj)
        )
    }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'works for any type',
  {
    'test.ts': `export type A = any`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { A } from "./test";

    export function isA(obj: unknown): obj is A {
        const typedObj = obj as A
        return (
          true
        )
    }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'works for unknown type',
  {
    'test.ts': `export type A = unknown`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { A } from "./test";

    export function isA(obj: unknown): obj is A {
        const typedObj = obj as A
        return (
          true
        )
    }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'any and unknown work in union types',
  {
    'test.ts': `
    type anyType = any
    type unknownType = unknown

    export type AnyOrString = string | anyType
    export type UnknownOrString = string | unknownType
    export type AnyOrUnknownOrString = string | anyType | unknownType`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { AnyOrString, UnknownOrString, AnyOrUnknownOrString } from "./test";

    export function isAnyOrString(obj: unknown): obj is AnyOrString {
        const typedObj = obj as AnyOrString
        return (
          true
        )
    }

    export function isUnknownOrString(obj: unknown): obj is UnknownOrString {
      const typedObj = obj as UnknownOrString
      return (
        true
      )
    }

    export function isAnyOrUnknownOrString(obj: unknown): obj is AnyOrUnknownOrString {
        const typedObj = obj as AnyOrUnknownOrString
        return (
          true
        )
    }`,
  },
  { options: { exportAll: true } }
)

testProcessProject(
  'any and unknown work in interesction types',
  {
    'test.ts': `
    type anyType = any
    type unknownType = unknown

    export type AnyAndString = string & anyType
    export type UnknownAndString = string & unknownType
    export type AnyAndUnknownAndString = string & anyType & unknownType`,
  },
  {
    'test.ts': null,
    'test.guard.ts': `
    import { AnyAndString, UnknownAndString, AnyAndUnknownAndString } from "./test";

    export function isAnyAndString(obj: unknown): obj is AnyAndString {
        const typedObj = obj as AnyAndString
        return (
          true
        )
    }

    export function isUnknownAndString(obj: unknown): obj is UnknownAndString {
      const typedObj = obj as UnknownAndString
      return (
        typeof typedObj === "string"
      )
    }

    export function isAnyAndUnknownAndString(obj: unknown): obj is AnyAndUnknownAndString {
        const typedObj = obj as AnyAndUnknownAndString
        return (
          true
        )
    }`,
  },
  { options: { exportAll: true } }
)
